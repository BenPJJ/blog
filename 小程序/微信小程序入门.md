# 微信小程序入门

## 页面的跳转

### 1. 三种跳转方法

#### `wx.navigateTo()`

保留当前页面（父页面，执行`onHide()方法`），跳转到其他页面（子页面），最后可以返回到当前页面（父页面），两个页面之间是**父子关系**

#### `wx.redirectTo()`

关闭当前页面（执行`onUnload()方法`），跳转到其他页面，无法返回，两个页面是**平行关系**

#### `wx.switchTab()`

专门跳转到带有`tabBar` 的页面，并关闭其他所有非`tabBar` 页面，使用上面两种跳转方式是无效的。从`tabBar` 的页面跳转到非`tabBar` 的页面，可以使用上面的两种方式

### 2. 区分绝对和相对路径

#### 绝对路径

一般在前面加上`/` ，表示从根目录开始往下寻找

#### 相对路径

相对于当前页面来说，每次使用`../` 就是往上跳出一层

### 3. demo

``` js
wx.navigateTo({
  url: "/pages/nav/nav"
})
```

## 轮播组件swiper

`swiper` 通常是配合着`swiper-item` 来使用的，前者是整个轮播图的容器，后者是单一轮播子项目容器，仅在前者内部使用，宽高默认为`swiper` 的宽高

### 1. 修饰符

- `vertical = true` 设置轮播滚动方向
- `indicator-dots = true` 指示器的显示

### 2. demo

``` html
<swiper class="swiper">
  <swiper-item>1</swiper-item>
  <swiper-item>2</swiper-item>
  <swiper-item>3</swiper-item>
</swiper>
```

## 事件的绑定

### 1. 事件一般分两种

#### 冒泡事件

点击了子节点，父节点上面的事件也会执行；但是点击父节点上面的事件，子节点上面的事件不会执行

`bind` 开头：表示冒泡，后面接事件名

#### 非冒泡事件

当一个组件上的事件被触发后，该事件不会向父节点传递。一般在子节点上面添加

`catch` 开头：表示非冒泡，后面接事件名

### 2. demo

``` html
// 冒泡事件
<view bindtap='onbind'>
我是事件2
<view bindtap='onBind'>我是事件1</view>
</view>

// 非冒泡事件
<view	catchtap='onbind'>
我是事件2
<view catchtap='onBind'>我是事件1</view>
</view>
```

## tabBar页面配置

`tabBar` 是在全局`app.json` 里面配置，其中的`list` 数组最少配置2个，最多5个

**注意：页面跳转需要使用`wx.switchTab`**

### 1. demo

``` js
"tabBar": {
  "position": "top", // 按钮的位置，默认为bottom，设置top的时候，icon设置无效
    "borderStyle": "white", // tabBar的颜色，black/white两种
      "list": [
        {
          "pagePath": "pages/logs/logs", // 页面路径，必须在pages 属性中定义
          "text": "logs",
          "iconPath": "image/laud.png", // 未选中的图片
          "selectedIconPath": "image/comment.png" // 选中的图片
        },
        {
          "pagePath": "pages/test/test",
          "text": "test",
          "iconPath": "image/laud.png",
          "selectedIconPath": "image/comment.png"
        }
      ]
},
```

## 数据的绑定

### 1. 方式

小程序里面没有`dom节点` 的概念，不能够像使用`jQuery` 一样，通过操作DOM 节点来给页面添加数据。相反小程序通过数据绑定，来达到数据优先。

小程序的数据绑定，都是从`Page` 中的`data属性` 中读取数据去完成数据绑定。这个读取`data` 属性中的数据去绑定到页面的动作是发生在`onLoad` 事件之后的 

### 2. 好处

不用操作DOM，减少页面加载的时间

### 3. 主动更新数据

#### `this.setDate()` 

方法接收一个对象，把里面接收到的数据，绑定到`Page` 下面的`data属性` 里面，而通过`this.data.xxx = xxx` 是绑定不了数据到页面上的，不过也不会报错

### 4. demo

``` html
// 绑定一个数据
<view>{{key}}</view>
// 绑定多个数据
<view>{{key1}}{{key2}}</view>
// 属性上绑定数据
<view src="{{key}}"></view>
```

## 数据的循环

### 1. 数据

#### 内部

``` js
Page({
  onLoad: function () {
    var datasArr = [{
      date: '2018/2/3',
      title: '神盾局特工1',
      content: '神盾局特工这个礼拜六停播，说好的不停歇的呢？'
    }, {
      date: '2018/2/3',
      title: '神盾局特工2',
      content: '神盾局特工科学组cp要结婚啦！'
    }]
    this.setData({
      datesArry: datasArr
    });
  }
})
```

#### 外部

```  js
// data.js
var datasArr = [{
  date: '2018/2/3',
  title: '神盾局特工1',
  content: '神盾局特工这个礼拜六停播，说好的不停歇的呢？'
}, {
  date: '2018/2/3',
  title: '神盾局特工2',
  content: '神盾局特工科学组cp要结婚啦！'
}]

module.exports = {
  datesArry: datasArr
}
```

``` js
var datesArry = require('../../data.js');

Page({
  onLoad: function () {
    this.setData(datesArry);
  }
})
```

### 2. demo

``` html
<view class="container" wx:for='{{datesArry}}' wx:for-item="item" wx:for-index="idx" wx:key="idx">
  <view>{{item.date}}</view>
  <view>{{item.title}}</view>
  <view>{{item.content}}</view>
</view>
```



